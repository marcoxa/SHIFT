/* -*- Mode: C -*- */

/* gen-iterators.c -- */

/*
 * Copyright (c)1996, 1997, 1998 The Regents of the University of
 * California (Regents). All Rights Reserved. 
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for educational, research, and not-for-profit purposes,
 * without fee and without a signed licensing agreement, is hereby
 * granted, provided that the above copyright notice, this paragraph and
 * the following two paragraphs appear in all copies, modifications, and
 * distributions. 
 *
 * Contact The Office of Technology Licensing, UC Berkeley, 2150 Shattuck
 * Avenue, Suite 510, Berkeley, CA 94720-1620, (510) 643-7201, for
 * commercial licensing opportunities. 
 *
 * IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
 * SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
 * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
 * REGENTS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 *
 * REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF
 * ANY, PROVIDED HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION
 * TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 * MODIFICATIONS. 
 */

/* Code generation for aggregate iterators (sets and arrays.)
 * Marco Antoniotti 19970105
 */

#ifndef COMPILER_GEN_ITER_I
#define COMPILER_GEN_ITER_I

#include <shift_config.h>

#include <assert.h>
#include <stdio.h>
#include <stdarg.h>

/* #include "lisp.h" */
#include "crscl.h"

#include "shic.h"
#include "utilities.h"

/* generate_expression -- declared and defined in 'generate.c' */

extern void
generate_expression(lv*);


/* call_generator2 -- declared and defined in 'generate.c' */

extern void
call_generator2(char*, lv*, lv*);


/* Utility functions and macros */

void
gen_var_name(char* var_format_name, char* result)
{
  /* 'var_format_name' must contain a '%d' directive. */
  static int name_count = 0;

  sprintf(result, var_format_name, name_count++);
}


/* cons_generator -- */

void
cons_generator(lv *e)
{

  if (args(e))
    {
      lv *et = arg1(attr(intern("type"), e));
      lv *ht = attr(intern("hashed_type"), et);
      int tn = num(attr(intern("unique"), ht));

      fprintf(cfile, "%s_cons(&typed%d, %d",
	      op(e) == intern("arraycons") ? "array" : "set", tn, length(args(e)));
      dolist (a, args(e))
	{
	  fprintf(cfile, ", ");
	  generate_expression(a);
	}
      tsilod;
      fprintf(cfile, ")");
    }
  else
    {
      /* Adding support for built-in sets that are
       * generated by the DOT notation.
       *
       * Tunc Simsek 19980528
       */
      lv *intrinsic = attr(intern("components"), e);
      lv *t = type_of(e);
      /*******MAK***** implementation for null sets - create an overhead */

#define _get_unique_hash_id_(_t_)  intnum(attr(intern("unique"),	\
					       attr(intern("hashed_type"), \
						    arg1((_t_)))))

      if (intrinsic)
	{
	  fprintf(cfile, 
		  "intrinsic_set_cons(&typed%d)",
		  _get_unique_hash_id_(t));

	}
      else if (op(t) == intern("null_set"))
	{
	  fprintf(cfile, 
		  "set_cons(&typed%d, 0)",
		  _get_unique_hash_id_(t));
	}
      else if (op(t) == intern("empty_array"))
	{
	  fprintf(cfile, 
		  "array_cons(&typed%d, 0)",
		  _get_unique_hash_id_(t));
	}
      else
	{ 
	  fprintf(cfile, "0");
	}
    }
}


/* set_former_generator, array_former_generator --
 * Marco Antoniotti 19970101
 */
void
set_former_generator(lv* e)
{
  fprintf(cfile, "set_former_F%d(_self)", intnum(attr(intern("unique"), e)));
}


void
array_former_generator(lv* e)
{
  fprintf(cfile, "array_former_F%d(_self)", intnum(attr(intern("unique"), e)));
}


void
index_generator(lv *e)
{
  lv *t = attr(intern("type"), e);

  /* The 'op(t) == intern("id")' is a brutish hack.
   * We really need to figure out a better way to decide whether we
   * have an instance here and not a subarray or set.
   *
   * Marco Antoniotti 19970207
   */
  call_generator2(op(t) == intern("number_type") ? "*double_index" :
		  op(t) == intern("symbol_type")
		  || op(t) == intern("logical_type") ? "*int_index" :
		  op(t) == intern("id") ? "(Component*) *voidstar_index" :
		  "*voidstar_index",
		  args(e),
		  0);
}

void
copy_set_generator(lv *e)
{
  fprintf(cfile, "(Set *)copy_set((GenericSet *)");
  generate_expression(arg1(e));
  fprintf(cfile, ");\n");
}

void
copy_array_generator(lv *e)
{
  fprintf(cfile, "(Array *)copy_array((GenericArray *)");
  generate_expression(arg1(e));
  fprintf(cfile, ");\n");
}


static int
compute_full_indent_level(lv *iterator_exprs)
{
  if (iterator_exprs == 0)
    return 0;
  else if (op(arg2(first(iterator_exprs))) == intern("arrayrange"))
    return 2 + compute_full_indent_level(rest(iterator_exprs));
  else				/* should be a set range */
    return 1 + compute_full_indent_level(rest(iterator_exprs));
}


/* generate_set_former_function, generate_array_former_function --
 * Added to handle set and array formers through iteration.
 * A set former expression like:
 *     { E(x, y) : x in S1, y in S2 | P(x, y) }
 * is translated in a function like

GenericSet*
set_former_FN(Component* _self)
{
  GenericSet* _set_N = new_set();

  FOR_ALL_ELEMENTS(x, S1)
    {
      FOR_ALL_ELEMENTS(y, S2)
	{
	  if (P(x, y))
	    add_to_set(E(x, y), _set_N);
	}
      END_FAE;
    }
  END_FAE;

  return _set_N;
}

 *
 * An array former is an expression like:
 *     [ E(x, y) : x in S1, y in S2 | P(x, y) ]
 * and is translated into a more complex form accordinf with the
 * following algorithm.
 * 1 - fill in a list with the elements of the array (actually in
 *     reverse order)
 * 2 - create the new array
 * 3 - fill it in with elements from the list.
 *
 * This is necessary because arrays in SHIFT are of fixed size and we
 * do not know beforehand how many elements the array former will
 * actually produce.
 *
 * Marco Antoniotti 19970101
 */

void
generate_set_former_function(lv* set_former_expr)
{
  /* The lengths are arbitrary and chose just for convenience.  They
   * are used only in this function and others directly called from
   * this one.
   */

  char indent[3] = "  ";
  char new_set_var_name[80];
  char new_el_var_name[80];
  int indent_level = 1;

  int u = num(attr(intern("unique"), set_former_expr));
  lv* element_expr   = arg1(set_former_expr);
  lv* iterator_exprs = arg2(set_former_expr);
  lv* filter_expr    = arg3(set_former_expr);
  lv* element_type   = arg1(attr(intern("type"), set_former_expr));
  lv* hashed_element_type = attr(intern("hashed_type"), element_type);
  int element_type_u = num(attr(intern("unique"), hashed_element_type));
  int n_iterator_exprs = length(iterator_exprs);
  int el_expr_indent_level = compute_full_indent_level(iterator_exprs);

  /* Forward declarations */
  void generate_new_set_element_code(char[], lv*, lv*);
  void generate_loop_headers(lv*, int);
  void generate_loop_closing(lv*, int);

  fprintf(hfile, "extern Set * set_former_F%d(Component*);\n", u);

  fprintf(cfile, "Set *\nset_former_F%d(Component* _self)\n{\n", u);

  /* Generate new set variable name */
  sprintf(new_set_var_name, "_set_N%d", u);
  fprintf(cfile,
	  "%sGenericSet* %s = new_set(&typed%d);\n",
	  indent,
	  new_set_var_name,
	  element_type_u);

  /* Generate name of temporary variable which will hold the new set
   * element.
   */
  sprintf(new_el_var_name, "_set_N%d_element", u);
  fprintf(cfile,
	  "%svid %s;\n\n",
	  indent,
	  new_el_var_name);

  /* Generate the nested loops */
  generate_loop_headers(iterator_exprs, indent_level);

  /* Now generate the filter expression */
  indent_to(indent_level + el_expr_indent_level, indent, cfile);
  fprintf(cfile, "if (");
  generate_expression(filter_expr);
  fprintf(cfile, ")\n");

  /* Generate the adding of elements to the new set */
  indent_to(indent_level + el_expr_indent_level + 1, indent, cfile);
  fprintf(cfile, "{\n");

  indent_to(indent_level + el_expr_indent_level + 2, indent, cfile);
  generate_new_set_element_code(new_el_var_name,
				element_type,
				element_expr);

  indent_to(indent_level + el_expr_indent_level + 2, indent, cfile);
  fprintf(cfile, "add_to_set(%s, %s);\n",
	  new_el_var_name,
	  new_set_var_name);

  indent_to(indent_level + el_expr_indent_level + 1, indent, cfile);
  fprintf(cfile, "}\n");

  /* Close the nested loops.  Note the */
  generate_loop_closing(nreverse(copy_list(iterator_exprs)),
			indent_level + (el_expr_indent_level - 1));
  
  fprintf(cfile, "%sreturn (Set *) _set_N%d;\n", indent, u);
  fputs("}\n\n", cfile);
}


/* generate_array_former_function --
 * The array generating functions are "heavier" than the set related
 * ones, since we do not necessarily know beforehand how long the array
 * is going to be.  Since arrays in SHIFT are of fixed size, we solve
 * the problem with the following scheme:
 * generate a list of <index, element> pairs (why? why can't I use
 * Lisp?!?) and then fill in the appropriate array.
 */
void
generate_array_former_function(lv* array_former_expr)
{
  /* The lengths are arbitrary and chose just for convenience.  They
   * are used only in this function and others directly called from
   * this one.
   */

  char indent[3] = "  ";
  char new_array_var_name[80];
  char new_el_var_name[80];
  char new_temp_list_el_name[80];
  char count_var_name[80];
  int indent_level = 1;

  int u = num(attr(intern("unique"), array_former_expr));
  lv* element_expr   = arg1(array_former_expr);
  lv* iterator_exprs = arg2(array_former_expr);
  lv* filter_expr    = arg3(array_former_expr);
  lv* element_type   = arg1(attr(intern("type"), array_former_expr));
  lv* hashed_element_type = attr(intern("hashed_type"), element_type);
  int element_type_u = num(attr(intern("unique"), hashed_element_type));
  int n_iterator_exprs = length(iterator_exprs);

  /* Forward declarations */
  void generate_new_array_element_memo_code(char[], char[], lv*, lv*, int);
  void generate_loop_headers(lv*, int);
  void generate_loop_closing(lv*, int);
  void generate_array_filling_loop(char[], char[], char[], lv*, int);

  /* Here we go!! */
  fprintf(hfile, "extern Array * array_former_F%d(Component*);\n", u);

  fprintf(cfile, "Array *\narray_former_F%d(Component* _self)\n{\n", u);

  /* Generate the name of the variable which will contain the acual
   * Array.
   */
  sprintf(new_array_var_name, "_array_N%d", u);
  indent_to(indent_level, indent, cfile);
  fprintf(cfile, "Array* %s;\n", new_array_var_name);

  /* Generate name of temporary variable which will hold the list of
   * temporary <index, element> entries.
   * Note the type.
   */
  sprintf(new_temp_list_el_name, "_array_N%d_temp_i_ae", u);
  indent_to(indent_level, indent, cfile);
  fprintf(cfile, "struct _i_ae { vid entry; struct _i_ae *next ; }");
  fprintf(cfile, " *%s = 0;\n", new_temp_list_el_name);

  /* Generate name of variable containing the length of the array
   * being grown and an auxiliary one.
   */
  sprintf(count_var_name, "_array_N%d_el_count", u);
  indent_to(indent_level, indent, cfile);
  fprintf(cfile, "int %s = 0;\n", count_var_name);
  indent_to(indent_level, indent, cfile);
  fprintf(cfile, "int _array_former_i = 0;\n");

  /* Generate the nested loops */
  generate_loop_headers(iterator_exprs, indent_level);

  /* Now generate the filter expression */
  indent_to(indent_level + n_iterator_exprs, indent, cfile);
  fprintf(cfile, "if (");
  generate_expression(filter_expr);
  fprintf(cfile, ")\n");

  /* Generate the adding of elements to the new set */
  indent_to(indent_level + n_iterator_exprs + 1, indent, cfile);
  fprintf(cfile, "{\n");

  indent_to(indent_level + n_iterator_exprs + 2, indent, cfile);
  generate_new_array_element_memo_code(new_temp_list_el_name,
				       count_var_name,
				       element_type,
				       element_expr,
				       indent_level + n_iterator_exprs +2);

  indent_to(indent_level + n_iterator_exprs + 1, indent, cfile);
  fprintf(cfile, "}\n");

  generate_loop_closing(nreverse(copy_list(iterator_exprs)),
			indent_level + length(iterator_exprs) - 1);

  /* Generate the code for the new array and the loop that actually
   * fills the array.
   */ 
  putc('\n', cfile);
  indent_to(indent_level, indent, cfile);
  fputs("/* Actually create the new array and fill it in. */\n", cfile);
  indent_to(indent_level, indent, cfile);
  fprintf(cfile, "%s = (Array*) new_array(&typed%d, ",
	  new_array_var_name,
	  element_type_u);
  fprintf(cfile, "%s);\n", count_var_name);
  
  indent_to(indent_level, indent, cfile);
  generate_array_filling_loop(new_array_var_name,
			      new_temp_list_el_name,
			      count_var_name,
			      element_type,
			      indent_level);

  /* Generate the code returning the new array */
  indent_to(indent_level, indent, cfile);
  fprintf(cfile, "return (Array *) %s;\n", new_array_var_name);
  fprintf(cfile, "}\n\n");
}


void
generate_new_set_element_code(char new_el_var_name[],
			      lv* element_type,
			      lv* element_expr)
{
  lv* element_type_class = op(element_type);

  fprintf(cfile, "%s.", new_el_var_name);
  if (element_type_class == intern("number_type"))
    fprintf(cfile, "d = ");
  else if (element_type_class == intern("symbol_type")
	   || element_type_class == intern("logical_type"))
    fprintf(cfile, "i = ");
  else /* everything else */
    fprintf(cfile, "v = ");

  generate_expression(element_expr);
  fprintf(cfile, ";\n");
  /* fprintf(cfile, "<the element expression>;\n"); */
}


void
generate_new_array_element_memo_code(char new_temp_list_el_name[],
				     char count_var_name[],
				     lv* element_type,
				     lv* element_expr,
				     int indent_level)
{
  lv* element_type_class = op(element_type);
  char indent[3] = "  ";

  /* Generate code to fill in the list and to increment the counter */

  fprintf(cfile, "/* Add to head of list of new elements. */\n\n");

  indent_to(indent_level, indent, cfile);
  fprintf(cfile, "struct _i_ae *__new_list_el\n");
  indent_to(indent_level + 2, indent, cfile);
  fprintf(cfile, "= (struct _i_ae *)malloc(sizeof(struct _i_ae));\n\n");

  indent_to(indent_level, indent, cfile);
  fprintf(cfile, "__new_list_el->next = %s;\n", new_temp_list_el_name);

  indent_to(indent_level, indent, cfile);
  fprintf(cfile, "%s = __new_list_el;\n", new_temp_list_el_name);

  indent_to(indent_level, indent, cfile);
  fprintf(cfile, "%s++;\n", count_var_name);


  /* Finally generate the code for the creation of the new element */

  indent_to(indent_level, indent, cfile);
  fprintf(cfile, "__new_list_el->entry.");

  if (element_type_class == intern("number_type"))
    fprintf(cfile, "d = ");
  else if (element_type_class == intern("symbol_type")
	   || element_type_class == intern("logical_type"))
    fprintf(cfile, "i = ");
  else /* everything else */
    fprintf(cfile, "v = ");

  generate_expression(element_expr);
  fprintf(cfile, ";\n");
}


void
generate_array_filling_loop(char new_array_var_name[],
			    char new_temp_list_el_name[],
			    char count_var_name[],
			    lv* element_type,
			    int indent_level)
{
  char indent[3] = "  ";
  lv* element_type_class = op(element_type);
  char union_field;

  /* Most of the code generation hereafter depends on the selection of
   * the approriate field in the union 'entry'.
   */
  if (element_type_class == intern("number_type"))
    union_field = 'd';
  else if (element_type_class == intern("symbol_type")
	   || element_type_class == intern("logical_type"))
    union_field = 'i';
  else /* everything else */
    union_field = 'v';

  /* Here we go... */
  fprintf(cfile, "for (_array_former_i = %s - 1;\n", count_var_name);
  indent_to(indent_level, indent, cfile);
  fprintf(cfile, "     _array_former_i >= 0 && %s != 0;\n", new_temp_list_el_name);
  indent_to(indent_level, indent, cfile);
  fprintf(cfile, "     _array_former_i--, %s = %s->next)\n",
	  new_temp_list_el_name,
	  new_temp_list_el_name);

  indent_to(indent_level + 1, indent, cfile);
  fprintf(cfile, "{\n");
  
  /* The type casting generated is absolutely gross!
   * But what can I do?!?
   *
   * Marco Antoniotti 19970107
   */
  indent_to(indent_level + 2, indent, cfile);
  fprintf(cfile, "array_set(%s, _array_former_i, %s(%s(%s->entry.%c)));\n",
	  new_array_var_name,
	  union_field == 'v' ? "" : "(void*)",
	  union_field == 'v' ? "" : "&",
	  new_temp_list_el_name,
	  union_field);

  indent_to(indent_level + 1, indent, cfile);
  fprintf(cfile, "}\n\n");

  /* Lest also generate a sanity check! */
  indent_to(indent_level, indent, cfile);
  fputs("/* Check that the construction actually went as expected. */\n",
	cfile);
  indent_to(indent_level, indent, cfile);
  fprintf(cfile, "if (! (_array_former_i < 0 && %s == 0))\n",
	  new_temp_list_el_name);
  indent_to(indent_level + 1, indent, cfile);
  fputs("runtime_error(\"internal: incorrect array construction.\");\n\n",
	cfile);
}

void
generate_set_loop_header(lv* iterator_expr, int indent_level)
{
  char indent[3] = "  ";
  char iter_var_name[80];
  lv*  iter_var_type = type_of(arg1(iterator_expr));

  gen_var_name("_set_N%d_cursor", iter_var_name);

  indent_to(indent_level, indent, cfile);
  fprintf(cfile, "FOR_ALL_ELEMENTS(");
  fprintf(cfile, "%s, ", iter_var_name);
  generate_expression(arg2(iterator_expr));
  fprintf(cfile, ") {\n");
  
  indent_to(indent_level + 1, indent, cfile);
  LHS = 1;
  generate_expression(arg1(iterator_expr));
  LHS = 0;

  fprintf(cfile, " = %s", iter_var_name);

  if (number_type_p(iter_var_type))
    fputs(".d;", cfile);
  else if (symbol_type_p(iter_var_type) || logical_type_p(iter_var_type))
    fputs(".i;", cfile);
  else
    fputs(".v;", cfile);

  fputc('\n', cfile);
}

/* Code with iterator variables allocated on the C stack.
void
generate_set_loop_header(lv* iterator_expr, int indent_level)
{
  char indent[3] = "  ";

  indent_to(indent_level, indent, cfile);
  fprintf(cfile, "FOR_ALL_ELEMENTS(");
  fprintf(cfile, "%s, ", pname(attr(intern("name"), arg1(iterator_expr))));
  generate_expression(arg2(iterator_expr));
  fprintf(cfile, ") {\n");
}
*/


void
generate_range_loop_header(lv* iterator_expr, int indent_level)
{
  /* We need to actually declare the loop variable
   *
   * Note: we may have to introduce a new block in the case
   * the C compiler chokes
   */
  char indent[3] = "  ";
  char iter_var_name[80];
  lv* step_expr_info = attr(intern("step_expr"), arg2(iterator_expr)); /* a 'by_expr' */
  lv* step_expr = arg1(step_expr_info);

  gen_var_name("_array_N%d_cursor", iter_var_name);

  /* Since the for loop may be generated inside another loop, we must
   * make provisions to enclose the loop variable in a separate inner
   * block.
   * Marco Antoniotti 19970904
   */
  indent_to(indent_level, indent, cfile);
  fputs("{\n", cfile);

  indent_to(indent_level + 1, indent, cfile);
  fprintf(cfile, "%s %s;\n",
	  attr(intern("discrete"), attr(intern("step_expr"), arg2(iterator_expr))) == intern("true") ?
	  "int" : "double",
	  iter_var_name);
	  
  indent_to(indent_level + 1, indent, cfile);

  /* Generate init step from first bound */
  fprintf(cfile, "for (%s = ", iter_var_name);
  generate_expression(attr(intern("bound1"), arg2(iterator_expr)));
  fputs("; ", cfile);

  /* Generate loop condition stating both bounds */
  fprintf(cfile, "%s >= ", iter_var_name);
  generate_expression(attr(intern("bound1"), arg2(iterator_expr)));
  fputs(" && ", cfile);

  fprintf(cfile, "%s <= ", iter_var_name);
  generate_expression(attr(intern("bound2"), arg2(iterator_expr)));
  fputs("; ", cfile);

  if (attr(intern("discrete"), step_expr_info)
      && attr(intern("type"), step_expr) == discrete_number_type
      && attr(intern("value"), step_expr) != nil
      && fixnump(attr(intern("value"), step_expr))
      && num(attr(intern("value"), step_expr)) == 1)
    fprintf(cfile, "%s%s) {\n",
	    iter_var_name,
	    attr(intern("direction"), step_expr_info) == intern("ascending") ? "++" : "--"
	    );
  else
    {
      fprintf(cfile, "%s %s= ",
	      iter_var_name,
	      attr(intern("direction"), step_expr_info) == intern("ascending") ? "+" : "-"
	      );
      generate_expression(step_expr);
      fprintf(cfile, ") {\n");
    }

  /* Now make sure that the cursor is saved. */
  indent_to(indent_level + 2, indent, cfile);
  LHS = 1;
  generate_expression(arg1(iterator_expr));
  LHS = 0;
  fprintf(cfile, " = %s;\n", iter_var_name);
}

/* Code with iterator variables allocated on the C stack.
void
generate_range_loop_header(lv* iterator_expr, int indent_level)
{
  / **** We need to actually declare the loop variable
   *
   * Note: we may have to introduce a new block in the case
   * the C compiler chokes
   **** /
  char indent[3] = "  ";
  char* iter_var_name = pname(attr(intern("name"), arg1(iterator_expr)));
  lv* step_expr_info = attr(intern("step_expr"), arg2(iterator_expr)); / * a 'by_expr' * /
  lv* step_expr = arg1(step_expr_info);

  indent_to(indent_level, indent, cfile);

  fprintf(cfile, "%s %s;\n",
	  attr(intern("discrete"), attr(intern("step_expr"), arg2(iterator_expr))) == intern("true") ?
	  "int" : "double",
	  iter_var_name);
	  
  indent_to(indent_level, indent, cfile);

  / * Generate init step from first bound * /
  fprintf(cfile, "for (%s = ", iter_var_name);
  generate_expression(attr(intern("bound1"), arg2(iterator_expr)));
  fputs("; ", cfile);

  / * Generate loop condition stating both bounds * /
  fprintf(cfile, "%s >= ", iter_var_name);
  generate_expression(attr(intern("bound1"), arg2(iterator_expr)));
  fputs(" && ", cfile);

  fprintf(cfile, "%s <= ", iter_var_name);
  generate_expression(attr(intern("bound2"), arg2(iterator_expr)));
  fputs("; ", cfile);

  if (attr(intern("discrete"), step_expr_info)
      && attr(intern("type"), step_expr) == discrete_number_type
      && attr(intern("value"), step_expr) != nil
      && fixnump(attr(intern("value"), step_expr))
      && num(attr(intern("value"), step_expr)) == 1)
    fprintf(cfile, "%s%s) {\n",
	    iter_var_name,
	    attr(intern("direction"), step_expr_info) == intern("ascending") ? "++" : "--"
	    );
  else
    {
      fprintf(cfile, "%s %s= ",
	      iter_var_name,
	      attr(intern("direction"), step_expr_info) == intern("ascending") ? "+" : "-"
	      );
      generate_expression(step_expr);
      fprintf(cfile, ") {\n");
    }
}
*/


void
generate_loop_headers(lv* iterator_exprs, int indent_level)
{
  if (iterator_exprs != nil)
    {
      if (op(arg2(first(iterator_exprs))) == intern("arrayrange"))
	generate_range_loop_header(first(iterator_exprs), indent_level);
      else			/* set expression */
	generate_set_loop_header(first(iterator_exprs), indent_level);

      generate_loop_headers(rest(iterator_exprs), indent_level + 1);
    }
}


/* generate_loop_closing -- To be always called with the indent level
 * of the innermost expression (the 'if' for the filter).
 */
void
generate_loop_closing(lv* iterator_exprs, int indent_level)
{
  char indent[3] = "  ";

  if (iterator_exprs)
    {
      if (op(arg2(first(iterator_exprs))) == intern("arrayrange"))
	{
	  indent_to(indent_level, indent, cfile);
	  fprintf(cfile, "} /* for loop block */\n");
	  indent_to(indent_level - 1, indent, cfile);
	  fprintf(cfile, "} /* for loop cursor block */\n");
	}
      else			/* should be a set... */
	{
	  indent_to(indent_level - 1, indent, cfile);
	  fprintf(cfile, "} END_FAE;\n");
	}
      generate_loop_closing(rest(iterator_exprs), indent_level--);
    }
}


/* generate_exists_function -- */

void
generate_exists_function_range(lv* exists_expr)
{
  lv *id = attr(intern("id"), exists_expr);
  lv *id_type = attr(intern("type"), id);
  lv* range_expr = arg1(exists_expr);
  int u = num(attr(intern("unique"), exists_expr));
  int indent_level = 1;
  char indent[3] = "  ";
  char* iter_var_name = "__array_range_i";
  lv* step_expr_info = attr(intern("step_expr"), range_expr); /* a 'by_expr' */
  lv* step_expr = arg1(step_expr_info);

  fprintf(hfile,
	  "extern int exists_expr_range_F%d(Component *);\n", u);

  fprintf(cfile,
	  "int\nexists_expr_range_F%d(Component *_self)\n{\n", u);

  indent_to(indent_level, indent, cfile);
  if (attr(intern("discrete"), step_expr_info))
    fputs("int", cfile);
  else
    generate_type(id_type, cfile);
  fprintf(cfile, " %s;\n\n", iter_var_name);

  /* Generate init step from first bound */
  indent_to(indent_level, indent, cfile);
  fprintf(cfile, "for (%s = ", iter_var_name);
  generate_expression(attr(intern("bound1"), range_expr));
  fputs("; ", cfile);

  /* Generate loop condition stating both bounds */
  fprintf(cfile, "%s >= ", iter_var_name);
  generate_expression(attr(intern("bound1"), range_expr));
  fputs(" && ", cfile);

  fprintf(cfile, "%s <= ", iter_var_name);
  generate_expression(attr(intern("bound2"), range_expr));
  fputs("; ", cfile);

  /* Generate step expression */
  if (attr(intern("discrete"), step_expr_info)
      && attr(intern("type"), step_expr) == discrete_number_type
      && attr(intern("value"), step_expr) != nil
      && fixnump(attr(intern("value"), step_expr))
      && num(attr(intern("value"), step_expr)) == 1)
    fprintf(cfile, "%s%s) {\n",
	    iter_var_name,
	    attr(intern("direction"), step_expr_info) == intern("ascending") ? "++" : "--"
	    );
  else
    {
      fprintf(cfile, "%s %s= ",
	      iter_var_name,
	      attr(intern("direction"), step_expr_info) == intern("ascending") ? "+" : "-"
	      );
      generate_expression(step_expr);
      fprintf(cfile, ") {\n");
    }

  indent_to(indent_level + 1, indent, cfile);
  id_generator(id);
  fprintf(cfile, " = (double)%s;\n", iter_var_name); /* Yes.  We know
						      * that this is
						      * correct.  All
						      * SHIFT number
						      * types boil down
						      * to a double.
						      */
  indent_to(indent_level + 1, indent, cfile);
  fprintf(cfile, "if (");
  generate_expression(arg2(exists_expr));
  fprintf(cfile, ") return 1;\n");
  indent_to(indent_level, indent, cfile);
  fputs("}\n", cfile);
  indent_to(indent_level, indent, cfile);
  fputs("return 0;\n}\n\n", cfile);
}


void
generate_exists_function_set(lv* exists_expr)
{
  lv *id = attr(intern("id"), exists_expr);
  lv *id_type = attr(intern("type"), id);
  int u = num(attr(intern("unique"), exists_expr));
  int indent_level = 1;
  char indent[3] = "  ";

  fprintf(hfile,
	  "extern int exists_expr_F%d(Component *, void *);\n", u);

  fprintf(cfile,
	  "int\nexists_expr_F%d(Component *_self, void *_set)\n{\n", u);

  indent_to(indent_level, indent, cfile);
  fprintf(cfile, "FOR_ALL_ELEMENTS(__set_el, _set) {\n");

  indent_to(indent_level + 1, indent, cfile);
  id_generator(id);

  if (number_type_p(id_type))
    {
      fprintf(cfile, " = __set_el.d;\n");
    }
  else if (symbol_type_p(id_type) || logical_type_p(id_type))
    {
      fprintf(cfile, " = __set_el.i;\n");
    }
  else
    {
      fprintf(cfile, " = (");
      generate_type(id_type, cfile);
      fprintf(cfile, ") __set_el.v;\n");
    }
  indent_to(indent_level + 1, indent, cfile);
  fprintf(cfile, "if (");
  generate_expression(arg2(exists_expr));
  fprintf(cfile, ") return 1;\n");

  indent_to(indent_level, indent, cfile);
  fputs("} END_FAE;\n\n", cfile);
  indent_to(indent_level, indent, cfile);
  fputs("return 0;\n}\n\n", cfile);
}

void
generate_exists_function(lv *exists_expr)
{
  if (op(arg1(exists_expr)) == intern("arrayrange"))
    {
      generate_exists_function_range(exists_expr);
    }
  else
    {
      generate_exists_function_set(exists_expr);
    }
}


/* generate_minmax_function - This function generates code that cannot
 * run now.
 * '*_DO_ALL_ELEMENTS' and 'first_element' do not exist yet.
 * Marco Antoniotti 19970107
 */
void
generate_minmax_function(lv *q, int max)
{
  lv *id = attr(intern("id"), q);
  int u = num(attr(intern("unique"), q));
  lv *t = attr(intern("type"), q);

  char indent[3] = "  ";
  int indent_level = 1;

  char *prefix =
    (op(t) == intern("number_type")) ? "double" :
    (op(t) == intern("logical_type") || op(t) == intern("symbol_type")) ? "int" :
    "voidstar";

  char set_field =
    (op(t) == intern("number_type")) ? 'd' :
    (op(t) == intern("logical_type") || op(t) == intern("symbol_type")) ? 'i' :
    'v';

  if (op(arg1(q)) == intern("arrayrange"))
    {
      internal_error("'minel' and 'maxel' operators\
over ranges have not yet been implemented");
    }
  else
    {
      fputs("extern ", hfile);
      generate_type(t, hfile);
      fprintf(hfile, " minmax_expr_F%d(Component*, void*);\n", u);


      generate_type(t, cfile);
      fprintf(cfile, "\nminmax_expr_F%d(Component *_self, void *_set)\n{\n", u);

      indent_to(indent_level, indent, cfile);
      fputs("double _mm;\n", cfile);

      indent_to(indent_level, indent, cfile);
      generate_type(t, cfile);
      fprintf(cfile, " _e;\n");

      putc('\n', cfile);

      /* Generate code to handle empty set */
      indent_to(indent_level, indent, cfile);
      fprintf(cfile, "if (empty_set_p((GenericSet*) _set))\n");
      indent_to(indent_level + 1, indent, cfile);
      fprintf(cfile,
	      "runtime_error(\"'%sel' operator called on an empty set\");\n\n",
	      max == 1 ? "max" : "min");

      indent_to(indent_level, indent, cfile);
      LHS = 1;
      id_generator(id);
      LHS = 0;
      fprintf(cfile, " = %s_first_element((GenericSet*) _set);\n", prefix);
  
      indent_to(indent_level, indent, cfile);
      fputs("_e = ", cfile);
      id_generator(id);
      fprintf(cfile, ";\n");

      indent_to(indent_level, indent, cfile);
      fputs("_mm = ", cfile);
      generate_expression(arg2(q));
      fprintf(cfile, ";\n");

      indent_to(indent_level, indent, cfile);
      fprintf(cfile, "DO_ALL_ELEMENTS(");
      LHS = 1;
      id_generator(id);
      LHS = 0;
      fprintf(cfile, ", _set, %s, %c) {\n", prefix, set_field);

      indent_to(indent_level + 1, indent, cfile);
      fputs("double _mx = ", cfile);
      generate_expression(arg2(q));
      fprintf(cfile, ";\n");

      indent_to(indent_level + 1, indent, cfile);
      fprintf(cfile, "if (_mx %s _mm)\n", max ? " > " : " < ");

      indent_to(indent_level + 2, indent, cfile);
      fputs("{\n", cfile);

      indent_to(indent_level + 3, indent, cfile);
      fputs("_mm = _mx;\n", cfile);

      indent_to(indent_level + 3, indent, cfile);
      fputs("_e = ", cfile);
      id_generator(id);
      fputs(";\n", cfile);

      indent_to(indent_level + 2, indent, cfile);
      fputs("}\n", cfile);

      indent_to(indent_level + 1, indent, cfile);
      fputs("}\n", cfile);

      indent_to(indent_level, indent, cfile);
      fputs("END_DAE;\n", cfile);

      indent_to(indent_level, indent, cfile);
      fputs("return _e;\n}\n\n", cfile);
    }
}


/* generate_reduce_form_function -- */
void
generate_reduce_form_function(lv* reduce_form)
{
  ;
}

#endif /* COMPILER_GEN_ITER_I */

/* end of file -- gen-iterators.c -- */
